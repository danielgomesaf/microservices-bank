#
# DEFAULT PROPERTIES OF H2 DATABASE. EVEN IF NOT MENTIONED
# SPRING WILL USE THIS CREDENTIALS.
#
spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driver-class-name=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
spring.h2.console.enabled=true
server.port=8080

# INSERTED TO MAKE INSERTS IN THE DATA.SQL WORK
# SINCE SPRING VERSION 2.5 THIS PROPERTY HAS TO BE ADDED
# TO SINALIZE THAT THE DATA.SQL FILE HAS TO BE USED
spring.jpa.defer-datasource-initialization=true

# PROPERTIES TO ACCESS CONFIG SERVER
# spring.application.name = name of the application config files
# spring.profiles.active = name of the environment that is currently active
# spring.config.import = endpoint of the config server that contains all the configs
# the optional parameter indicates that, if for some reason the config server
# is down or unreachable, the account microservice will initialize anyway
spring.application.name=accounts
spring.profiles.active=prod
spring.config.import=optional:configserver:http://localhost:8071/

# property that indicate that all of spring actuator endpoints are exposed
# by default, Spring actuator does not expose the /refresh url, which is the
# endpoint responsible for refreshing the config properties without the need to
# restart the microservice
management.endpoints.web.exposure.include=*

# Adding properties to enable connection to the eureka server
# Service Registry Agent

# When a microservice register himself into a eureka server
# by default, it uses it's hostname. In a container environment, a ip address
# changes constantly, so it's advisable to register with a ip address
# So this property is setted to assure that a registration of a microservice
# into a eureka server will be done using preferably a ip address
eureka.instance.preferIpAddress=true

eureka.client.registerWithEureka=true
eureka.client.fetchRegistry=true
eureka.client.serviceUrl.defaultZone=http://localhost:8070/eureka/

## Configuring info endpoint
management.info.env.enabled=true
info.app.name=Accounts Microservice
info.app.description=Bank Accounts Application
info.app.version=1.0.0

management.endpoint.shutdown.enabled=true

# OVERRIDING CONFIGURATIONS OF RESILIENCE4J FOR CIRCUIT BREAKER PATTERN

# tell to resilience4j to register all of my health information from my actuator. Default value is false
resilience4j.circuitbreaker.configs.default.register-health-indicator=true

# monitor minimun number of calls to this api to keep the circuit closed. Default value is 50.
resilience4j.circuitbreaker.instances.detailsForCustomerSupportApp.minimum-number-of-calls=5

# set the threshold to open my circuit. The value is set in percentage.
resilience4j.circuitbreaker.instances.detailsForCustomerSupportApp.failure-rate-threshold=50

# tell how much time circuit breaker has to wait to half-open the circuit to check if the failure self-healed
resilience4j.circuitbreaker.instances.detailsForCustomerSupportApp.wait-duration-in-open-state=30000

# sets when in half-open state, how much calls are allowed to receive.
resilience4j.circuitbreaker.instances.detailsForCustomerSupportApp.permitted-number-of-calls-in-half-open-state=2

# OVERRIDING CONFIGURATIONS OF RESILIENCE4J FOR RETRY PATTERN

# number of attempts that retry pattern will retry the call. This number will take into account
# the original call, so if will want your application to try 3 times plus the original, the max-attempts
# should be configured as 4, not 3.
resilience4j.retry.instances.retryForCustomerDetails.max-attempts=3

# duration of each retry in milliseconds.
resilience4j.retry.instances.retryForCustomerDetails.wait-duration=2000

# OVERRIDING CONFIGURATIONS OF RESILIENCE4J FOR RATE LIMITER PATTERN

# tell to resilience4j to register all of my health information from my actuator. Default value is false
resilience4j.ratelimiter.configs.default.register-health-indicator=true

# how much time my thread has to wait to get a place so that it can invoke the request
# once the rate limiter is accepting new requests
resilience4j.ratelimiter.instances.sayHello.timeout-duration=5000

# number of requests that this api will accept in the time configured in timeout duration
# for testing purposes, the value is set as 1
resilience4j.ratelimiter.instances.sayHello.limit-for-period=1

resilience4j.ratelimiter.instances.sayHello.limit-refresh-period=5000

# ADDING SPRING SLEUTH AND ZIPKIN PROPERTIES
# percentage of requests that is send to zipkin server
# 1 = 100%, 0.5 = 50%. Default value is 10%
# The default value takes into account a large application with thousands of logs
# so low performance is the reason for not sending all logs to the server
spring.sleuth.sampler.probability=1

spring.zipkin.base-url=http://localhost:9411/